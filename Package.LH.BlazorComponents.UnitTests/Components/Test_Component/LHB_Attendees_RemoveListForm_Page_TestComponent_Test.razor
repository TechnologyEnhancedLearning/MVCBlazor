@using AutoFixture
@using FluentAssertions
@using Moq
@using Package.LH.BlazorComponents.UnitTests.DependencyInjection
@using Package.LH.BlazorComponents.UnitTests.TestDoubles
@using Package.LH.Entities.Models
@using Package.LH.Services.StateServices
@using Package.Shared.BlazorComponents.BaseComponents.Buttons
@using Package.Shared.BlazorComponents.Components.Lists
@using Package.Shared.BlazorComponents.Core
@using Package.Shared.Entities.Communication
@using Package.Shared.Entities.Models
@using Package.Shared.Services.ComponentServices
@using Package.Shared.Services.StateServices.CharacterStateServices
@using Package.LH.BlazorComponents.Components.Test_Components
@using Package.Shared.BlazorComponents.UnitTests.DependencyInjection
@using Microsoft.AspNetCore.Components @*only added to enable @<mycomponent /> syntax if not worked remove*@
@inherits TestContext

@code{

    private readonly Fixture _fixture;

    public LHB_Attendees_RemoveListForm_Page_TestComponent_Test()
    {
        // Initialize AutoFixture
        _fixture = new Fixture();
    }

    private TestContext GetTestContext(bool JSIsEnabled, bool useFallBackService = true)
    {
        var ctx = new TestContext();

        if (useFallBackService)
        {
            ctx.Services.AddFallbackServiceProvider(new FallbackServiceProvider());
        }

        // Create a mock of IGS_JSEnabled
        var mockJSEnabled = new Mock<IGS_JSEnabled>();
        mockJSEnabled.Setup(js => js.JSIsEnabled).Returns(JSIsEnabled); // Mock behavior for JSIsEnabled
        mockJSEnabled.Setup(js => js.TestingWhoAmI).Returns("MockedHost"); // Mock behavior for WhoAmI

        ctx.Services.AddScoped(_ => mockJSEnabled.Object);

        return ctx;

    }

    [Theory]
    [InlineData(true)]
    [InlineData(false)]
    public void LHB_Attendees_RemoveListForm_Page_TestComponent_UpdatesUIAfterAttendeeRemoved(bool JSIsEnabled)
    {

        @if (!JSIsEnabled) { throw new NotImplementedException("This should in fact fail if nojs TestContext behaved as statically rendered"); }

        // Arrange
        TestContext ctxJSEnabled = GetTestContext(JSIsEnabled);
        ctxJSEnabled.Services.AddTestDouble_LHS_AttendeesStateServices();
        var noJSActionUrl = _fixture.Create<string>();

        var cut = ctxJSEnabled.RenderComponent<LHB_Attendees_RemoveListForm_Page_TestComponent>();

        cut.SaveSnapshot();
        var initialMarkup = cut.Markup;
        int initialRemoveButtonCount = cut.FindAll(".danger-list-item-btn").Count();
        //Click the first remove button
        var firstRemoveButton = cut.Find(".danger-list-item-btn");
        firstRemoveButton.Click();
        var diff = cut.GetChangesSinceSnapshot();
        var currentMarkup = cut.Markup;
        int finalRemoveButtonCount = cut.FindAll(".danger-list-item-btn").Count();
        //Assert
        Assert.True(diff.Count() > 0);
        Assert.NotEqual(initialMarkup, currentMarkup);
        Assert.Equal(initialRemoveButtonCount - 1, finalRemoveButtonCount);



    }
    /// <summary>
    /// Here we are testing efficiency of the rerender but also trying some BUnit features.
    /// QQQQ very much in progress
    /// </summary>
    /// <param name="JSIsEnabled"></param>
    /// <exception cref="NotImplementedException"></exception>

    [Theory]
    [InlineData(true)]
    [InlineData(false)]
    public void LHB_Attendees_RemoveListForm_Page_TestComponent_UpdatesUIAfterAttendeeRemovedResultsInSingleChange(bool JSIsEnabled)
    {

        @if (!JSIsEnabled) { throw new NotImplementedException("This should in fact fail if nojs TestContext behaved as statically rendered"); }

        // Arrange
        TestContext ctxJSEnabled = GetTestContext(JSIsEnabled);
        ctxJSEnabled.Services.AddTestDouble_LHS_AttendeesStateServices();
        var noJSActionUrl = _fixture.Create<string>();

        var cut = ctxJSEnabled.RenderComponent<LHB_Attendees_RemoveListForm_Page_TestComponent>();


        cut.SaveSnapshot();
        var firstMarkup = cut.Markup;
        //Click the first remove button
        var firstRemoveButton = cut.Find(".danger-list-item-btn");
        firstRemoveButton.Click();

        var diff = cut.GetChangesSinceSnapshot();
        var currentMarkup = cut.Markup;
        //qqqq Getting 596 this indicates I am inefficiently rerendering though it may be unavoidable, come back to this after statehandling task?

        //Assert
        var firstRemoveButtonMarkup = firstRemoveButton.ToMarkup();
        
        //Check the button matches expectation
        firstRemoveButton.MarkupMatches(@"<button diff:ignoreAttributes diff:ignoreChildren></button>");
        firstRemoveButton.MarkupMatches(@"<button type=""submit""
                    class=""nhsuk-generic-button nhsuk-danger-button nhsuk-inline-button danger-list-item-btn""
                    aria-label:ignore
                    aria-role:ignore
                    aria-describedby:ignore
                    title=""Remove the attendee from the list"" 
                    tabindex=""0""
                    diff:ignoreChildren></button>");
        

        /*
                @<button type="" submit""
                    class="nhsuk-generic-button nhsuk-danger-button nhsuk-inline-button danger-list-item-btn"
                    aria-label="Remove attendee *"
                    aria-role="Button"
                    title="Remove the attendee from the list">
                <i class="bi bi bi-trash nhsuk-icon" aria-hidden="true"></i>
                Remove
                <span class=""nhsuk-assistive-text"">*</span>
            </button>

         */
        // bool isMarkup1ContainedInMarkup2 =
        //    MarkupMatches(
        //        markup2,
        //        markup1,
        //        ignoreAttributes: new[] { "aria-label", "aria-role", "aria-describedby" }
        //    );

        Assert.False(currentMarkup.ToString().Contains(firstRemoveButton.ToString()));
        diff.ShouldHaveChanges(
            diff => diff.ShouldBeRemoval(@"<li diff:ignoreAttributes diff:ignoreChildren></li>")//,
              //diff => diff.ShouldBeAddition("<li>Second item</li>")
                );
        diff.ShouldHaveSingleChange();
        diff.ShouldHaveSingleChange().ShouldBeRemoval(@"<li diff:ignoreAttributes diff:ignoreChildren></li>");//QQQQ supposedly bad practice but i cant provide the html as includes random data
        Assert.False(currentMarkup.ToString().Contains(firstRemoveButton.ToString()));


        /*
         
            <button type="submit" 
            class="nhsuk-generic-button nhsuk-danger-button nhsuk-inline-button danger-list-item-btn" 
            aria-label="Remove attendee af97c22c-c1d3-4a30-ab3d-980749de3c6a ec923862-2aff-47f6-b084-9125a47ad8ca" 
            aria-role="Button" aria-describedby="assistive-text-51a3b6ea-28cc-47b8-978e-76432aff0b42" 
            title="Remove the attendee from the list" tabindex="0">
            <i class="bi bi bi-trash nhsuk-icon" 
            aria-hidden="true" style="padding-right: 10px;"></i>
            Remove
            <span id="assistive-text-51a3b6ea-28cc-47b8-978e-76432aff0b42" class="nhsuk-assistive-text">Remove attendee af97c22c-c1d3-4a30-ab3d-980749de3c6a ec923862-2aff-47f6-b084-9125a47ad8ca via inline buttons preceeding list items</span>
            </button>


         */

    }

    [Theory]
    [InlineData(true)]
    [InlineData(false)]
    public void LHB_Attendees_RemoveListForm_Page_TestComponent_UsingComponentInstances_RemoveButtonRemovesElementAndAttendee(bool JSIsEnabled)
    {

        @if (!JSIsEnabled) { throw new NotImplementedException("This should in fact fail if nojs TestContext behaved as statically rendered"); }

        // Arrange
        TestContext ctxJSEnabled = GetTestContext(JSIsEnabled);
        ctxJSEnabled.Services.AddTestDouble_LHS_AttendeesStateServices();
        var attendeesStateService = ctxJSEnabled.Services.GetService<ILHS_AttendeesStateService>();
        int originalAttendeesStateServiceAttendeesCount = attendeesStateService?.Attendees.Count()??0;
        var noJSActionUrl = _fixture.Create<string>();

        var cut = ctxJSEnabled.RenderComponent<LHB_Attendees_RemoveListForm_Page_TestComponent>();


        var canWeGrabIt = cut.FindComponent<LHB_Attendees_RemoveListForm_TestComponent>();
        var canWeGrabIt1 = cut.FindComponent<Shared.BlazorComponents.Components.Lists.GB_ListWithButtons<LH_AttendeeModel>>();
        var canWeGrabIt2 = cut.FindComponent<GB_Button2>();

        var canWeGrabItFromAnother = canWeGrabIt.FindComponent<Shared.BlazorComponents.Components.Lists.GB_ListWithButtons<LH_AttendeeModel>>();
        int ItemsCount = canWeGrabItFromAnother.Instance.Items.Count();
        var canWeGrabItFromAnother1 = canWeGrabItFromAnother.FindComponent<GB_Button2>();

        //Ah it is hidden somewhere!
        string ClientTemporaryId = canWeGrabItFromAnother1.Instance.FormData["clientTemporaryId"];
        canWeGrabItFromAnother1.Find("button").Click();



        // Assert

        //Our button is made with a render fragment and an event it has no exposed reference to the LH_Attendee
        Assert.True(canWeGrabItFromAnother1.IsDisposed);
        Assert.Equal(ItemsCount -1, canWeGrabItFromAnother.Instance.Items.Count());

        Assert.True(canWeGrabIt2.IsDisposed);
        Assert.Equal(ItemsCount - 1, canWeGrabIt1.Instance.Items.Count());

        Assert.Equal(canWeGrabIt.Instance.Attendees.Count(), canWeGrabIt1.Instance.Items.Count());

        Assert.Equal(originalAttendeesStateServiceAttendeesCount - 1, attendeesStateService?.Attendees.Count());

        Assert.DoesNotContain(ClientTemporaryId, attendeesStateService?.Attendees.Select(x => x.ClientTemporaryId).Select(x =>x.ToString()).ToList());

        attendeesStateService?.Attendees.Should().NotContain(x => x.ClientTemporaryId.ToString() == ClientTemporaryId);
    }




    [Theory]
    [InlineData(true)]
    [InlineData(false)]
    public async Task LHB_Attendees_RemoveListForm_Page_TestComponent_SaveButtonCallsHandleSubmit(bool JSIsEnabled)
    {

        // Arrange
        TestContext ctxJSEnabled = GetTestContext(JSIsEnabled);
        ctxJSEnabled.Services.AddTestDouble_LHS_AttendeesStateServices();
        var noJSActionUrl = _fixture.Create<string>();

        // Arrange
        IFAKE_LHS_AttendeesStateServices attendeesStateService = ctxJSEnabled.Services.GetService<IFAKE_LHS_AttendeesStateServices>();

        List<LH_AttendeeModel> attendees = attendeesStateService.Attendees;
        //Freeze
        GE_ServiceResponse<List<LH_AttendeeModel>> lastServiceResponseStartEmpty =
        new GE_ServiceResponse<List<LH_AttendeeModel>>
            {
                Success = attendeesStateService.T_LastServiceResponse.Success,
                Message = attendeesStateService.T_LastServiceResponse.Message,
                Data = attendeesStateService.T_LastServiceResponse.Data
            };

        var cut = ctxJSEnabled.RenderComponent<LHB_Attendees_RemoveListForm_Page_TestComponent>();

        @if (!JSIsEnabled)
        {
            //Assert
            Assert.Empty(cut.FindAll(".update-db"));

        }
        else
        {
            var updateDbButton = cut.Find(".update-db");
            updateDbButton.Click();
            await Task.Delay(3000);
            // Should start empty
            lastServiceResponseStartEmpty.Should().BeEquivalentTo(new GE_ServiceResponse<List<LH_AttendeeModel>>());
            Assert.NotEmpty(attendees);

            attendeesStateService.T_LastServiceResponse.Should().BeEquivalentTo(
            new GE_ServiceResponse<List<LH_AttendeeModel>>()
                {
                    Success = true,
                    Message = "",
                    Data = attendees
                });
            Assert.Equal(attendeesStateService.T_LastServiceResponse.Data, attendeesStateService.Attendees);
        }

    }
}
